use crate::code2::Arg;

#[derive(Debug)]
pub enum FateOp {
    RETURN,
    RETURNR(Arg),
    CALL(Arg),
    CALL_R(Arg, Arg, Arg, Arg, Arg),
    CALL_T(Arg),
    CALL_GR(Arg, Arg, Arg, Arg, Arg, Arg),
    JUMP(Arg),
    JUMPIF(Arg, Arg),
    SWITCH_V2(Arg, Arg, Arg),
    SWITCH_V3(Arg, Arg, Arg, Arg),
    SWITCH_VN(Arg, Arg),
    CALL_VALUE,
    PUSH(Arg),
    DUPA(Arg),
    DUP(Arg),
    POP(Arg),
    INCA(Arg),
    INC(Arg),
    DECA(Arg),
    DEC(Arg),
    ADD(Arg, Arg),
    SUB(Arg, Arg),
    MUL(Arg, Arg),
    DIV(Arg, Arg),
    MOD(Arg, Arg),
    POW(Arg, Arg),
    STORE(Arg),
    SHA3(Arg),
    SHA256(Arg),
    BLAKE2B(Arg),
    LT(Arg, Arg),
    GT(Arg, Arg),
    EQ(Arg, Arg),
    ELT(Arg, Arg),
    EGT(Arg, Arg),
    NEQ(Arg, Arg),
    AND(Arg, Arg),
    OR(Arg, Arg),
    NOT(Arg),
    TUPLE(Arg),
    ELEMENT(Arg, Arg),
    SETELEMENT(Arg, Arg, Arg),
    MAP_EMPTY,
    MAP_LOOKUP(Arg, Arg),
    MAP_LOOKUPD(Arg, Arg, Arg),
    MAP_UPDATE(Arg, Arg, Arg),
    MAP_DELETE(Arg, Arg),
    MAP_MEMBER(Arg, Arg),
    MAP_FROM_LIST(Arg),
    MAP_SIZE(Arg),
    MAP_TO_LIST(Arg),
    IS_NIL(Arg),
    CONS(Arg, Arg),
    HD(Arg),
    TL(Arg),
    LENGTH(Arg),
    NIL,
    APPEND(Arg, Arg),
    STR_JOIN(Arg, Arg),
    INT_TO_STR(Arg),
    ADDR_TO_STR(Arg),
    STR_REVERSE(Arg),
    STR_LENGTH(Arg),
    BYTES_TO_INT(Arg),
    BYTES_TO_STR(Arg),
    BYTES_CONCAT(Arg, Arg),
    BYTES_SPLIT(Arg, Arg),
    INT_TO_ADDR(Arg),
    VARIANT(Arg, Arg, Arg),
    VARIANT_TEST(Arg, Arg),
    VARIANT_ELEMENT(Arg, Arg),
    BITS_NONEA,
    BITS_NONE,
    BITS_ALLA,
    BITS_ALL,
    BITS_ALL_N(Arg),
    BITS_SET(Arg, Arg),
    BITS_CLEAR(Arg, Arg),
    BITS_TEST(Arg, Arg),
    BITS_SUM(Arg),
    BITS_OR(Arg, Arg),
    BITS_AND(Arg, Arg),
    BITS_DIFF(Arg, Arg),
    BALANCE,
    ORIGIN,
    CALLER,
    BLOCKHASH(Arg),
    BENEFICIARY,
    TIMESTAMP,
    GENERATION,
    MICROBLOCK,
    DIFFICULTY,
    GASLIMIT,
    GAS,
    ADDRESS,
    GASPRICE,
    LOG0(Arg),
    LOG1(Arg, Arg),
    LOG2(Arg, Arg, Arg),
    LOG3(Arg, Arg, Arg, Arg),
    LOG4(Arg, Arg, Arg, Arg, Arg),
    SPEND(Arg, Arg),
    ORACLE_REGISTER(Arg, Arg, Arg, Arg, Arg, Arg),
    ORACLE_QUERY(Arg, Arg, Arg, Arg, Arg, Arg, Arg),
    ORACLE_RESPOND(Arg, Arg, Arg, Arg, Arg, Arg),
    ORACLE_EXTEND(Arg, Arg, Arg),
    ORACLE_GET_ANSWER(Arg, Arg, Arg, Arg),
    ORACLE_GET_QUESTION(Arg, Arg, Arg, Arg),
    ORACLE_QUERY_FEE(Arg),
    AENS_RESOLVE(Arg, Arg, Arg),
    AENS_PRECLAIM(Arg, Arg, Arg),
    AENS_CLAIM(Arg, Arg, Arg, Arg, Arg),
    AENS_UPDATE(Arg, Arg, Arg, Arg, Arg, Arg),
    AENS_TRANSFER(Arg, Arg, Arg, Arg),
    AENS_REVOKE(Arg, Arg, Arg),
    BALANCE_OTHER(Arg),
    VERIFY_SIG(Arg, Arg, Arg),
    VERIFY_SIG_SECP256K1(Arg, Arg, Arg),
    CONTRACT_TO_ADDRESS(Arg),
    AUTH_TX_HASH,
    ORACLE_CHECK(Arg, Arg, Arg),
    ORACLE_CHECK_QUERY(Arg, Arg, Arg, Arg),
    IS_ORACLE(Arg),
    IS_CONTRACT(Arg),
    IS_PAYABLE(Arg),
    CREATOR,
    ECVERIFY_SECP256K1(Arg, Arg, Arg),
    ECRECOVER_SECP256K1(Arg, Arg),
    ADDRESS_TO_CONTRACT(Arg),
    BLS12_381_G1_NEG(Arg),
    BLS12_381_G1_NORM(Arg),
    BLS12_381_G1_VALID(Arg),
    BLS12_381_G1_IS_ZERO(Arg),
    BLS12_381_G1_ADD(Arg, Arg),
    BLS12_381_G1_MUL(Arg, Arg),
    BLS12_381_G2_NEG(Arg),
    BLS12_381_G2_NORM(Arg),
    BLS12_381_G2_VALID(Arg),
    BLS12_381_G2_IS_ZERO(Arg),
    BLS12_381_G2_ADD(Arg, Arg),
    BLS12_381_G2_MUL(Arg, Arg),
    BLS12_381_GT_INV(Arg),
    BLS12_381_GT_ADD(Arg, Arg),
    BLS12_381_GT_MUL(Arg, Arg),
    BLS12_381_GT_POW(Arg, Arg),
    BLS12_381_GT_IS_ONE(Arg),
    BLS12_381_PAIRING(Arg, Arg),
    BLS12_381_MILLER_LOOP(Arg, Arg),
    BLS12_381_FINAL_EXP(Arg),
    BLS12_381_INT_TO_FR(Arg),
    BLS12_381_INT_TO_FP(Arg),
    BLS12_381_FR_TO_INT(Arg),
    BLS12_381_FP_TO_INT(Arg),
    AENS_LOOKUP(Arg),
    ORACLE_EXPIRY(Arg),
    AUTH_TX,
    STR_TO_LIST(Arg),
    STR_FROM_LIST(Arg),
    STR_TO_UPPER(Arg),
    STR_TO_LOWER(Arg),
    CHAR_TO_INT(Arg),
    CHAR_FROM_INT(Arg),
    CALL_PGR(Arg, Arg, Arg, Arg, Arg, Arg, Arg),
    CREATE(Arg, Arg, Arg),
    CLONE(Arg, Arg, Arg, Arg),
    CLONE_G(Arg, Arg, Arg, Arg, Arg),
    BYTECODE_HASH(Arg),
    FEE,
    ADDRESS_TO_BYTES(Arg),
    POSEIDON(Arg, Arg),
    MULMOD(Arg, Arg, Arg),
    BAND(Arg, Arg),
    BOR(Arg, Arg),
    BXOR(Arg, Arg),
    BNOT(Arg),
    BSL(Arg, Arg),
    BSR(Arg, Arg),
    BYTES_SPLIT_ANY(Arg, Arg),
    BYTES_SIZE(Arg),
    BYTES_TO_FIXED_SIZE(Arg, Arg),
    INT_TO_BYTES(Arg, Arg),
    STR_TO_BYTES(Arg),
    DBG_LOC(Arg, Arg),
    DBG_DEF(Arg, Arg),
    DBG_UNDEF(Arg, Arg),
    DBG_CONTRACT(Arg),
    DEACTIVATE,
    ABORT(Arg),
    EXIT(Arg),
    NOP,
}
impl FateOp {
    pub fn opcode(&self) -> u8 {
        use FateOp::*;
        match self {
            RETURN => 0x0,
            RETURNR(_) => 0x1,
            CALL(_) => 0x2,
            CALL_R(_, _, _, _, _) => 0x3,
            CALL_T(_) => 0x4,
            CALL_GR(_, _, _, _, _, _) => 0x5,
            JUMP(_) => 0x6,
            JUMPIF(_, _) => 0x7,
            SWITCH_V2(_, _, _) => 0x8,
            SWITCH_V3(_, _, _, _) => 0x9,
            SWITCH_VN(_, _) => 0xa,
            CALL_VALUE => 0xb,
            PUSH(_) => 0xc,
            DUPA(_) => 0xd,
            DUP(_) => 0xe,
            POP(_) => 0xf,
            INCA(_) => 0x10,
            INC(_) => 0x11,
            DECA(_) => 0x12,
            DEC(_) => 0x13,
            ADD(_, _) => 0x14,
            SUB(_, _) => 0x15,
            MUL(_, _) => 0x16,
            DIV(_, _) => 0x17,
            MOD(_, _) => 0x18,
            POW(_, _) => 0x19,
            STORE(_) => 0x1a,
            SHA3(_) => 0x1b,
            SHA256(_) => 0x1c,
            BLAKE2B(_) => 0x1d,
            LT(_, _) => 0x1e,
            GT(_, _) => 0x1f,
            EQ(_, _) => 0x20,
            ELT(_, _) => 0x21,
            EGT(_, _) => 0x22,
            NEQ(_, _) => 0x23,
            AND(_, _) => 0x24,
            OR(_, _) => 0x25,
            NOT(_) => 0x26,
            TUPLE(_) => 0x27,
            ELEMENT(_, _) => 0x28,
            SETELEMENT(_, _, _) => 0x29,
            MAP_EMPTY => 0x2a,
            MAP_LOOKUP(_, _) => 0x2b,
            MAP_LOOKUPD(_, _, _) => 0x2c,
            MAP_UPDATE(_, _, _) => 0x2d,
            MAP_DELETE(_, _) => 0x2e,
            MAP_MEMBER(_, _) => 0x2f,
            MAP_FROM_LIST(_) => 0x30,
            MAP_SIZE(_) => 0x31,
            MAP_TO_LIST(_) => 0x32,
            IS_NIL(_) => 0x33,
            CONS(_, _) => 0x34,
            HD(_) => 0x35,
            TL(_) => 0x36,
            LENGTH(_) => 0x37,
            NIL => 0x38,
            APPEND(_, _) => 0x39,
            STR_JOIN(_, _) => 0x3a,
            INT_TO_STR(_) => 0x3b,
            ADDR_TO_STR(_) => 0x3c,
            STR_REVERSE(_) => 0x3d,
            STR_LENGTH(_) => 0x3e,
            BYTES_TO_INT(_) => 0x3f,
            BYTES_TO_STR(_) => 0x40,
            BYTES_CONCAT(_, _) => 0x41,
            BYTES_SPLIT(_, _) => 0x42,
            INT_TO_ADDR(_) => 0x43,
            VARIANT(_, _, _) => 0x44,
            VARIANT_TEST(_, _) => 0x45,
            VARIANT_ELEMENT(_, _) => 0x46,
            BITS_NONEA => 0x47,
            BITS_NONE => 0x48,
            BITS_ALLA => 0x49,
            BITS_ALL => 0x4a,
            BITS_ALL_N(_) => 0x4b,
            BITS_SET(_, _) => 0x4c,
            BITS_CLEAR(_, _) => 0x4d,
            BITS_TEST(_, _) => 0x4e,
            BITS_SUM(_) => 0x4f,
            BITS_OR(_, _) => 0x50,
            BITS_AND(_, _) => 0x51,
            BITS_DIFF(_, _) => 0x52,
            BALANCE => 0x53,
            ORIGIN => 0x54,
            CALLER => 0x55,
            BLOCKHASH(_) => 0x56,
            BENEFICIARY => 0x57,
            TIMESTAMP => 0x58,
            GENERATION => 0x59,
            MICROBLOCK => 0x5a,
            DIFFICULTY => 0x5b,
            GASLIMIT => 0x5c,
            GAS => 0x5d,
            ADDRESS => 0x5e,
            GASPRICE => 0x5f,
            LOG0(_) => 0x60,
            LOG1(_, _) => 0x61,
            LOG2(_, _, _) => 0x62,
            LOG3(_, _, _, _) => 0x63,
            LOG4(_, _, _, _, _) => 0x64,
            SPEND(_, _) => 0x65,
            ORACLE_REGISTER(_, _, _, _, _, _) => 0x66,
            ORACLE_QUERY(_, _, _, _, _, _, _) => 0x67,
            ORACLE_RESPOND(_, _, _, _, _, _) => 0x68,
            ORACLE_EXTEND(_, _, _) => 0x69,
            ORACLE_GET_ANSWER(_, _, _, _) => 0x6a,
            ORACLE_GET_QUESTION(_, _, _, _) => 0x6b,
            ORACLE_QUERY_FEE(_) => 0x6c,
            AENS_RESOLVE(_, _, _) => 0x6d,
            AENS_PRECLAIM(_, _, _) => 0x6e,
            AENS_CLAIM(_, _, _, _, _) => 0x6f,
            AENS_UPDATE(_, _, _, _, _, _) => 0x70,
            AENS_TRANSFER(_, _, _, _) => 0x71,
            AENS_REVOKE(_, _, _) => 0x72,
            BALANCE_OTHER(_) => 0x73,
            VERIFY_SIG(_, _, _) => 0x74,
            VERIFY_SIG_SECP256K1(_, _, _) => 0x75,
            CONTRACT_TO_ADDRESS(_) => 0x76,
            AUTH_TX_HASH => 0x77,
            ORACLE_CHECK(_, _, _) => 0x78,
            ORACLE_CHECK_QUERY(_, _, _, _) => 0x79,
            IS_ORACLE(_) => 0x7a,
            IS_CONTRACT(_) => 0x7b,
            IS_PAYABLE(_) => 0x7c,
            CREATOR => 0x7d,
            ECVERIFY_SECP256K1(_, _, _) => 0x7e,
            ECRECOVER_SECP256K1(_, _) => 0x7f,
            ADDRESS_TO_CONTRACT(_) => 0x80,
            BLS12_381_G1_NEG(_) => 0x81,
            BLS12_381_G1_NORM(_) => 0x82,
            BLS12_381_G1_VALID(_) => 0x83,
            BLS12_381_G1_IS_ZERO(_) => 0x84,
            BLS12_381_G1_ADD(_, _) => 0x85,
            BLS12_381_G1_MUL(_, _) => 0x86,
            BLS12_381_G2_NEG(_) => 0x87,
            BLS12_381_G2_NORM(_) => 0x88,
            BLS12_381_G2_VALID(_) => 0x89,
            BLS12_381_G2_IS_ZERO(_) => 0x8a,
            BLS12_381_G2_ADD(_, _) => 0x8b,
            BLS12_381_G2_MUL(_, _) => 0x8c,
            BLS12_381_GT_INV(_) => 0x8d,
            BLS12_381_GT_ADD(_, _) => 0x8e,
            BLS12_381_GT_MUL(_, _) => 0x8f,
            BLS12_381_GT_POW(_, _) => 0x90,
            BLS12_381_GT_IS_ONE(_) => 0x91,
            BLS12_381_PAIRING(_, _) => 0x92,
            BLS12_381_MILLER_LOOP(_, _) => 0x93,
            BLS12_381_FINAL_EXP(_) => 0x94,
            BLS12_381_INT_TO_FR(_) => 0x95,
            BLS12_381_INT_TO_FP(_) => 0x96,
            BLS12_381_FR_TO_INT(_) => 0x97,
            BLS12_381_FP_TO_INT(_) => 0x98,
            AENS_LOOKUP(_) => 0x99,
            ORACLE_EXPIRY(_) => 0x9a,
            AUTH_TX => 0x9b,
            STR_TO_LIST(_) => 0x9c,
            STR_FROM_LIST(_) => 0x9d,
            STR_TO_UPPER(_) => 0x9e,
            STR_TO_LOWER(_) => 0x9f,
            CHAR_TO_INT(_) => 0xa0,
            CHAR_FROM_INT(_) => 0xa1,
            CALL_PGR(_, _, _, _, _, _, _) => 0xa2,
            CREATE(_, _, _) => 0xa3,
            CLONE(_, _, _, _) => 0xa4,
            CLONE_G(_, _, _, _, _) => 0xa5,
            BYTECODE_HASH(_) => 0xa6,
            FEE => 0xa7,
            ADDRESS_TO_BYTES(_) => 0xa8,
            POSEIDON(_, _) => 0xa9,
            MULMOD(_, _, _) => 0xaa,
            BAND(_, _) => 0xab,
            BOR(_, _) => 0xac,
            BXOR(_, _) => 0xad,
            BNOT(_) => 0xae,
            BSL(_, _) => 0xaf,
            BSR(_, _) => 0xb0,
            BYTES_SPLIT_ANY(_, _) => 0xb1,
            BYTES_SIZE(_) => 0xb2,
            BYTES_TO_FIXED_SIZE(_, _) => 0xb3,
            INT_TO_BYTES(_, _) => 0xb4,
            STR_TO_BYTES(_) => 0xb5,
            DBG_LOC(_, _) => 0xb6,
            DBG_DEF(_, _) => 0xb7,
            DBG_UNDEF(_, _) => 0xb8,
            DBG_CONTRACT(_) => 0xb9,
            DEACTIVATE => 0xfa,
            ABORT(_) => 0xfb,
            EXIT(_) => 0xfc,
            NOP => 0xfd,
        }
    }

    pub fn args(&self) -> crate::code2::Arguments {
        use FateOp::*;
        match self {
            RETURN => crate::code2::Arguments { args: vec![] },
            RETURNR(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            CALL(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            CALL_R(a1, a2, a3, a4, a5) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone()] },
            CALL_T(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            CALL_GR(a1, a2, a3, a4, a5, a6) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone()] },
            JUMP(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            JUMPIF(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            SWITCH_V2(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            SWITCH_V3(a1, a2, a3, a4) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()] },
            SWITCH_VN(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            CALL_VALUE => crate::code2::Arguments { args: vec![] },
            PUSH(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            DUPA(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            DUP(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            POP(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            INCA(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            INC(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            DECA(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            DEC(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            ADD(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            SUB(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            MUL(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            DIV(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            MOD(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            POW(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            STORE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            SHA3(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            SHA256(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLAKE2B(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            LT(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            GT(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            EQ(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            ELT(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            EGT(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            NEQ(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            AND(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            OR(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            NOT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            TUPLE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            ELEMENT(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            SETELEMENT(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            MAP_EMPTY => crate::code2::Arguments { args: vec![] },
            MAP_LOOKUP(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            MAP_LOOKUPD(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            MAP_UPDATE(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            MAP_DELETE(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            MAP_MEMBER(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            MAP_FROM_LIST(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            MAP_SIZE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            MAP_TO_LIST(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            IS_NIL(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            CONS(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            HD(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            TL(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            LENGTH(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            NIL => crate::code2::Arguments { args: vec![] },
            APPEND(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            STR_JOIN(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            INT_TO_STR(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            ADDR_TO_STR(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            STR_REVERSE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            STR_LENGTH(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BYTES_TO_INT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BYTES_TO_STR(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BYTES_CONCAT(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BYTES_SPLIT(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            INT_TO_ADDR(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            VARIANT(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            VARIANT_TEST(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            VARIANT_ELEMENT(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BITS_NONEA => crate::code2::Arguments { args: vec![] },
            BITS_NONE => crate::code2::Arguments { args: vec![] },
            BITS_ALLA => crate::code2::Arguments { args: vec![] },
            BITS_ALL => crate::code2::Arguments { args: vec![] },
            BITS_ALL_N(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BITS_SET(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BITS_CLEAR(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BITS_TEST(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BITS_SUM(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BITS_OR(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BITS_AND(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BITS_DIFF(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BALANCE => crate::code2::Arguments { args: vec![] },
            ORIGIN => crate::code2::Arguments { args: vec![] },
            CALLER => crate::code2::Arguments { args: vec![] },
            BLOCKHASH(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BENEFICIARY => crate::code2::Arguments { args: vec![] },
            TIMESTAMP => crate::code2::Arguments { args: vec![] },
            GENERATION => crate::code2::Arguments { args: vec![] },
            MICROBLOCK => crate::code2::Arguments { args: vec![] },
            DIFFICULTY => crate::code2::Arguments { args: vec![] },
            GASLIMIT => crate::code2::Arguments { args: vec![] },
            GAS => crate::code2::Arguments { args: vec![] },
            ADDRESS => crate::code2::Arguments { args: vec![] },
            GASPRICE => crate::code2::Arguments { args: vec![] },
            LOG0(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            LOG1(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            LOG2(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            LOG3(a1, a2, a3, a4) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()] },
            LOG4(a1, a2, a3, a4, a5) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone()] },
            SPEND(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            ORACLE_REGISTER(a1, a2, a3, a4, a5, a6) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone()] },
            ORACLE_QUERY(a1, a2, a3, a4, a5, a6, a7) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone(), a7.clone()] },
            ORACLE_RESPOND(a1, a2, a3, a4, a5, a6) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone()] },
            ORACLE_EXTEND(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            ORACLE_GET_ANSWER(a1, a2, a3, a4) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()] },
            ORACLE_GET_QUESTION(a1, a2, a3, a4) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()] },
            ORACLE_QUERY_FEE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            AENS_RESOLVE(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            AENS_PRECLAIM(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            AENS_CLAIM(a1, a2, a3, a4, a5) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone()] },
            AENS_UPDATE(a1, a2, a3, a4, a5, a6) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone()] },
            AENS_TRANSFER(a1, a2, a3, a4) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()] },
            AENS_REVOKE(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            BALANCE_OTHER(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            VERIFY_SIG(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            VERIFY_SIG_SECP256K1(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            CONTRACT_TO_ADDRESS(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            AUTH_TX_HASH => crate::code2::Arguments { args: vec![] },
            ORACLE_CHECK(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            ORACLE_CHECK_QUERY(a1, a2, a3, a4) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()] },
            IS_ORACLE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            IS_CONTRACT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            IS_PAYABLE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            CREATOR => crate::code2::Arguments { args: vec![] },
            ECVERIFY_SECP256K1(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            ECRECOVER_SECP256K1(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            ADDRESS_TO_CONTRACT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G1_NEG(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G1_NORM(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G1_VALID(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G1_IS_ZERO(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G1_ADD(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_G1_MUL(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_G2_NEG(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G2_NORM(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G2_VALID(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G2_IS_ZERO(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_G2_ADD(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_G2_MUL(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_GT_INV(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_GT_ADD(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_GT_MUL(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_GT_POW(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_GT_IS_ONE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_PAIRING(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_MILLER_LOOP(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BLS12_381_FINAL_EXP(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_INT_TO_FR(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_INT_TO_FP(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_FR_TO_INT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BLS12_381_FP_TO_INT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            AENS_LOOKUP(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            ORACLE_EXPIRY(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            AUTH_TX => crate::code2::Arguments { args: vec![] },
            STR_TO_LIST(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            STR_FROM_LIST(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            STR_TO_UPPER(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            STR_TO_LOWER(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            CHAR_TO_INT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            CHAR_FROM_INT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            CALL_PGR(a1, a2, a3, a4, a5, a6, a7) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone(), a7.clone()] },
            CREATE(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            CLONE(a1, a2, a3, a4) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()] },
            CLONE_G(a1, a2, a3, a4, a5) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone()] },
            BYTECODE_HASH(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            FEE => crate::code2::Arguments { args: vec![] },
            ADDRESS_TO_BYTES(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            POSEIDON(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            MULMOD(a1, a2, a3) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone(), a3.clone()] },
            BAND(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BOR(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BXOR(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BNOT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BSL(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BSR(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BYTES_SPLIT_ANY(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            BYTES_SIZE(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            BYTES_TO_FIXED_SIZE(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            INT_TO_BYTES(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            STR_TO_BYTES(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            DBG_LOC(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            DBG_DEF(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            DBG_UNDEF(a1, a2) => crate::code2::Arguments { args: vec![a1.clone(), a2.clone()] },
            DBG_CONTRACT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            DEACTIVATE => crate::code2::Arguments { args: vec![] },
            ABORT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            EXIT(a1) => crate::code2::Arguments { args: vec![a1.clone()] },
            NOP => crate::code2::Arguments { args: vec![] },
        }
    }
}
