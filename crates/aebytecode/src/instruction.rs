use crate::code::Arg;

pub enum AddressingMode {
    Short(u8),
    Long {
        low: u8,
        high: u8,
    }
}
#[derive(Debug)]
pub enum Instruction {
    Return,
    Returnr(Arg),
    Call(Arg),
    CallR(Arg, Arg, Arg, Arg, Arg),
    CallT(Arg),
    CallGr(Arg, Arg, Arg, Arg, Arg, Arg),
    Jump(Arg),
    Jumpif(Arg, Arg),
    SwitchV2(Arg, Arg, Arg),
    SwitchV3(Arg, Arg, Arg, Arg),
    SwitchVn(Arg, Arg),
    CallValue,
    Push(Arg),
    Dupa(Arg),
    Dup(Arg),
    Pop(Arg),
    Inca(Arg),
    Inc(Arg),
    Deca(Arg),
    Dec(Arg),
    Add(Arg, Arg),
    Sub(Arg, Arg),
    Mul(Arg, Arg),
    Div(Arg, Arg),
    Mod(Arg, Arg),
    Pow(Arg, Arg),
    Store(Arg),
    Sha3(Arg),
    Sha256(Arg),
    Blake2B(Arg),
    Lt(Arg, Arg),
    Gt(Arg, Arg),
    Eq(Arg, Arg),
    Elt(Arg, Arg),
    Egt(Arg, Arg),
    Neq(Arg, Arg),
    And(Arg, Arg),
    Or(Arg, Arg),
    Not(Arg),
    Tuple(Arg),
    Element(Arg, Arg),
    Setelement(Arg, Arg, Arg),
    MapEmpty,
    MapLookup(Arg, Arg),
    MapLookupd(Arg, Arg, Arg),
    MapUpdate(Arg, Arg, Arg),
    MapDelete(Arg, Arg),
    MapMember(Arg, Arg),
    MapFromList(Arg),
    MapSize(Arg),
    MapToList(Arg),
    IsNil(Arg),
    Cons(Arg, Arg),
    Hd(Arg),
    Tl(Arg),
    Length(Arg),
    Nil,
    Append(Arg, Arg),
    StrJoin(Arg, Arg),
    IntToStr(Arg),
    AddrToStr(Arg),
    StrReverse(Arg),
    StrLength(Arg),
    BytesToInt(Arg),
    BytesToStr(Arg),
    BytesConcat(Arg, Arg),
    BytesSplit(Arg, Arg),
    IntToAddr(Arg),
    Variant(Arg, Arg, Arg),
    VariantTest(Arg, Arg),
    VariantElement(Arg, Arg),
    BitsNonea,
    BitsNone,
    BitsAlla,
    BitsAll,
    BitsAllN(Arg),
    BitsSet(Arg, Arg),
    BitsClear(Arg, Arg),
    BitsTest(Arg, Arg),
    BitsSum(Arg),
    BitsOr(Arg, Arg),
    BitsAnd(Arg, Arg),
    BitsDiff(Arg, Arg),
    Balance,
    Origin,
    Caller,
    Blockhash(Arg),
    Beneficiary,
    Timestamp,
    Generation,
    Microblock,
    Difficulty,
    Gaslimit,
    Gas,
    Address,
    Gasprice,
    Log0(Arg),
    Log1(Arg, Arg),
    Log2(Arg, Arg, Arg),
    Log3(Arg, Arg, Arg, Arg),
    Log4(Arg, Arg, Arg, Arg, Arg),
    Spend(Arg, Arg),
    OracleRegister(Arg, Arg, Arg, Arg, Arg, Arg),
    OracleQuery(Arg, Arg, Arg, Arg, Arg, Arg, Arg),
    OracleRespond(Arg, Arg, Arg, Arg, Arg, Arg),
    OracleExtend(Arg, Arg, Arg),
    OracleGetAnswer(Arg, Arg, Arg, Arg),
    OracleGetQuestion(Arg, Arg, Arg, Arg),
    OracleQueryFee(Arg),
    AensResolve(Arg, Arg, Arg),
    AensPreclaim(Arg, Arg, Arg),
    AensClaim(Arg, Arg, Arg, Arg, Arg),
    AensUpdate(Arg, Arg, Arg, Arg, Arg, Arg),
    AensTransfer(Arg, Arg, Arg, Arg),
    AensRevoke(Arg, Arg, Arg),
    BalanceOther(Arg),
    VerifySig(Arg, Arg, Arg),
    VerifySigSecp256K1(Arg, Arg, Arg),
    ContractToAddress(Arg),
    AuthTxHash,
    OracleCheck(Arg, Arg, Arg),
    OracleCheckQuery(Arg, Arg, Arg, Arg),
    IsOracle(Arg),
    IsContract(Arg),
    IsPayable(Arg),
    Creator,
    EcverifySecp256K1(Arg, Arg, Arg),
    EcrecoverSecp256K1(Arg, Arg),
    AddressToContract(Arg),
    Bls12_381G1Neg(Arg),
    Bls12_381G1Norm(Arg),
    Bls12_381G1Valid(Arg),
    Bls12_381G1IsZero(Arg),
    Bls12_381G1Add(Arg, Arg),
    Bls12_381G1Mul(Arg, Arg),
    Bls12_381G2Neg(Arg),
    Bls12_381G2Norm(Arg),
    Bls12_381G2Valid(Arg),
    Bls12_381G2IsZero(Arg),
    Bls12_381G2Add(Arg, Arg),
    Bls12_381G2Mul(Arg, Arg),
    Bls12_381GtInv(Arg),
    Bls12_381GtAdd(Arg, Arg),
    Bls12_381GtMul(Arg, Arg),
    Bls12_381GtPow(Arg, Arg),
    Bls12_381GtIsOne(Arg),
    Bls12_381Pairing(Arg, Arg),
    Bls12_381MillerLoop(Arg, Arg),
    Bls12_381FinalExp(Arg),
    Bls12_381IntToFr(Arg),
    Bls12_381IntToFp(Arg),
    Bls12_381FrToInt(Arg),
    Bls12_381FpToInt(Arg),
    AensLookup(Arg),
    OracleExpiry(Arg),
    AuthTx,
    StrToList(Arg),
    StrFromList(Arg),
    StrToUpper(Arg),
    StrToLower(Arg),
    CharToInt(Arg),
    CharFromInt(Arg),
    CallPgr(Arg, Arg, Arg, Arg, Arg, Arg, Arg),
    Create(Arg, Arg, Arg),
    Clone(Arg, Arg, Arg, Arg),
    CloneG(Arg, Arg, Arg, Arg, Arg),
    BytecodeHash(Arg),
    Fee,
    AddressToBytes(Arg),
    Poseidon(Arg, Arg),
    Mulmod(Arg, Arg, Arg),
    Band(Arg, Arg),
    Bor(Arg, Arg),
    Bxor(Arg, Arg),
    Bnot(Arg),
    Bsl(Arg, Arg),
    Bsr(Arg, Arg),
    BytesSplitAny(Arg, Arg),
    BytesSize(Arg),
    BytesToFixedSize(Arg, Arg),
    IntToBytes(Arg, Arg),
    StrToBytes(Arg),
    DbgLoc(Arg, Arg),
    DbgDef(Arg, Arg),
    DbgUndef(Arg, Arg),
    DbgContract(Arg),
    Deactivate,
    Abort(Arg),
    Exit(Arg),
    Nop,
}
impl Instruction {
    pub fn opcode(&self) -> u8 {
        use Instruction::*;
        match self {
            Return => 0x0,
            Returnr(_) => 0x1,
            Call(_) => 0x2,
            CallR(_, _, _, _, _) => 0x3,
            CallT(_) => 0x4,
            CallGr(_, _, _, _, _, _) => 0x5,
            Jump(_) => 0x6,
            Jumpif(_, _) => 0x7,
            SwitchV2(_, _, _) => 0x8,
            SwitchV3(_, _, _, _) => 0x9,
            SwitchVn(_, _) => 0xa,
            CallValue => 0xb,
            Push(_) => 0xc,
            Dupa(_) => 0xd,
            Dup(_) => 0xe,
            Pop(_) => 0xf,
            Inca(_) => 0x10,
            Inc(_) => 0x11,
            Deca(_) => 0x12,
            Dec(_) => 0x13,
            Add(_, _) => 0x14,
            Sub(_, _) => 0x15,
            Mul(_, _) => 0x16,
            Div(_, _) => 0x17,
            Mod(_, _) => 0x18,
            Pow(_, _) => 0x19,
            Store(_) => 0x1a,
            Sha3(_) => 0x1b,
            Sha256(_) => 0x1c,
            Blake2B(_) => 0x1d,
            Lt(_, _) => 0x1e,
            Gt(_, _) => 0x1f,
            Eq(_, _) => 0x20,
            Elt(_, _) => 0x21,
            Egt(_, _) => 0x22,
            Neq(_, _) => 0x23,
            And(_, _) => 0x24,
            Or(_, _) => 0x25,
            Not(_) => 0x26,
            Tuple(_) => 0x27,
            Element(_, _) => 0x28,
            Setelement(_, _, _) => 0x29,
            MapEmpty => 0x2a,
            MapLookup(_, _) => 0x2b,
            MapLookupd(_, _, _) => 0x2c,
            MapUpdate(_, _, _) => 0x2d,
            MapDelete(_, _) => 0x2e,
            MapMember(_, _) => 0x2f,
            MapFromList(_) => 0x30,
            MapSize(_) => 0x31,
            MapToList(_) => 0x32,
            IsNil(_) => 0x33,
            Cons(_, _) => 0x34,
            Hd(_) => 0x35,
            Tl(_) => 0x36,
            Length(_) => 0x37,
            Nil => 0x38,
            Append(_, _) => 0x39,
            StrJoin(_, _) => 0x3a,
            IntToStr(_) => 0x3b,
            AddrToStr(_) => 0x3c,
            StrReverse(_) => 0x3d,
            StrLength(_) => 0x3e,
            BytesToInt(_) => 0x3f,
            BytesToStr(_) => 0x40,
            BytesConcat(_, _) => 0x41,
            BytesSplit(_, _) => 0x42,
            IntToAddr(_) => 0x43,
            Variant(_, _, _) => 0x44,
            VariantTest(_, _) => 0x45,
            VariantElement(_, _) => 0x46,
            BitsNonea => 0x47,
            BitsNone => 0x48,
            BitsAlla => 0x49,
            BitsAll => 0x4a,
            BitsAllN(_) => 0x4b,
            BitsSet(_, _) => 0x4c,
            BitsClear(_, _) => 0x4d,
            BitsTest(_, _) => 0x4e,
            BitsSum(_) => 0x4f,
            BitsOr(_, _) => 0x50,
            BitsAnd(_, _) => 0x51,
            BitsDiff(_, _) => 0x52,
            Balance => 0x53,
            Origin => 0x54,
            Caller => 0x55,
            Blockhash(_) => 0x56,
            Beneficiary => 0x57,
            Timestamp => 0x58,
            Generation => 0x59,
            Microblock => 0x5a,
            Difficulty => 0x5b,
            Gaslimit => 0x5c,
            Gas => 0x5d,
            Address => 0x5e,
            Gasprice => 0x5f,
            Log0(_) => 0x60,
            Log1(_, _) => 0x61,
            Log2(_, _, _) => 0x62,
            Log3(_, _, _, _) => 0x63,
            Log4(_, _, _, _, _) => 0x64,
            Spend(_, _) => 0x65,
            OracleRegister(_, _, _, _, _, _) => 0x66,
            OracleQuery(_, _, _, _, _, _, _) => 0x67,
            OracleRespond(_, _, _, _, _, _) => 0x68,
            OracleExtend(_, _, _) => 0x69,
            OracleGetAnswer(_, _, _, _) => 0x6a,
            OracleGetQuestion(_, _, _, _) => 0x6b,
            OracleQueryFee(_) => 0x6c,
            AensResolve(_, _, _) => 0x6d,
            AensPreclaim(_, _, _) => 0x6e,
            AensClaim(_, _, _, _, _) => 0x6f,
            AensUpdate(_, _, _, _, _, _) => 0x70,
            AensTransfer(_, _, _, _) => 0x71,
            AensRevoke(_, _, _) => 0x72,
            BalanceOther(_) => 0x73,
            VerifySig(_, _, _) => 0x74,
            VerifySigSecp256K1(_, _, _) => 0x75,
            ContractToAddress(_) => 0x76,
            AuthTxHash => 0x77,
            OracleCheck(_, _, _) => 0x78,
            OracleCheckQuery(_, _, _, _) => 0x79,
            IsOracle(_) => 0x7a,
            IsContract(_) => 0x7b,
            IsPayable(_) => 0x7c,
            Creator => 0x7d,
            EcverifySecp256K1(_, _, _) => 0x7e,
            EcrecoverSecp256K1(_, _) => 0x7f,
            AddressToContract(_) => 0x80,
            Bls12_381G1Neg(_) => 0x81,
            Bls12_381G1Norm(_) => 0x82,
            Bls12_381G1Valid(_) => 0x83,
            Bls12_381G1IsZero(_) => 0x84,
            Bls12_381G1Add(_, _) => 0x85,
            Bls12_381G1Mul(_, _) => 0x86,
            Bls12_381G2Neg(_) => 0x87,
            Bls12_381G2Norm(_) => 0x88,
            Bls12_381G2Valid(_) => 0x89,
            Bls12_381G2IsZero(_) => 0x8a,
            Bls12_381G2Add(_, _) => 0x8b,
            Bls12_381G2Mul(_, _) => 0x8c,
            Bls12_381GtInv(_) => 0x8d,
            Bls12_381GtAdd(_, _) => 0x8e,
            Bls12_381GtMul(_, _) => 0x8f,
            Bls12_381GtPow(_, _) => 0x90,
            Bls12_381GtIsOne(_) => 0x91,
            Bls12_381Pairing(_, _) => 0x92,
            Bls12_381MillerLoop(_, _) => 0x93,
            Bls12_381FinalExp(_) => 0x94,
            Bls12_381IntToFr(_) => 0x95,
            Bls12_381IntToFp(_) => 0x96,
            Bls12_381FrToInt(_) => 0x97,
            Bls12_381FpToInt(_) => 0x98,
            AensLookup(_) => 0x99,
            OracleExpiry(_) => 0x9a,
            AuthTx => 0x9b,
            StrToList(_) => 0x9c,
            StrFromList(_) => 0x9d,
            StrToUpper(_) => 0x9e,
            StrToLower(_) => 0x9f,
            CharToInt(_) => 0xa0,
            CharFromInt(_) => 0xa1,
            CallPgr(_, _, _, _, _, _, _) => 0xa2,
            Create(_, _, _) => 0xa3,
            Clone(_, _, _, _) => 0xa4,
            CloneG(_, _, _, _, _) => 0xa5,
            BytecodeHash(_) => 0xa6,
            Fee => 0xa7,
            AddressToBytes(_) => 0xa8,
            Poseidon(_, _) => 0xa9,
            Mulmod(_, _, _) => 0xaa,
            Band(_, _) => 0xab,
            Bor(_, _) => 0xac,
            Bxor(_, _) => 0xad,
            Bnot(_) => 0xae,
            Bsl(_, _) => 0xaf,
            Bsr(_, _) => 0xb0,
            BytesSplitAny(_, _) => 0xb1,
            BytesSize(_) => 0xb2,
            BytesToFixedSize(_, _) => 0xb3,
            IntToBytes(_, _) => 0xb4,
            StrToBytes(_) => 0xb5,
            DbgLoc(_, _) => 0xb6,
            DbgDef(_, _) => 0xb7,
            DbgUndef(_, _) => 0xb8,
            DbgContract(_) => 0xb9,
            Deactivate => 0xfa,
            Abort(_) => 0xfb,
            Exit(_) => 0xfc,
            Nop => 0xfd,
        }
    }

    pub fn args(&self) -> Vec<crate::code::Arg> {
        use Instruction::*;
        match self {
            Return => vec![],
            Returnr(a1) => vec![a1.clone()],
            Call(a1) => vec![a1.clone()],
            CallR(a1, a2, a3, a4, a5) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone()],
            CallT(a1) => vec![a1.clone()],
            CallGr(a1, a2, a3, a4, a5, a6) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone()],
            Jump(a1) => vec![a1.clone()],
            Jumpif(a1, a2) => vec![a1.clone(), a2.clone()],
            SwitchV2(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            SwitchV3(a1, a2, a3, a4) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()],
            SwitchVn(a1, a2) => vec![a1.clone(), a2.clone()],
            CallValue => vec![],
            Push(a1) => vec![a1.clone()],
            Dupa(a1) => vec![a1.clone()],
            Dup(a1) => vec![a1.clone()],
            Pop(a1) => vec![a1.clone()],
            Inca(a1) => vec![a1.clone()],
            Inc(a1) => vec![a1.clone()],
            Deca(a1) => vec![a1.clone()],
            Dec(a1) => vec![a1.clone()],
            Add(a1, a2) => vec![a1.clone(), a2.clone()],
            Sub(a1, a2) => vec![a1.clone(), a2.clone()],
            Mul(a1, a2) => vec![a1.clone(), a2.clone()],
            Div(a1, a2) => vec![a1.clone(), a2.clone()],
            Mod(a1, a2) => vec![a1.clone(), a2.clone()],
            Pow(a1, a2) => vec![a1.clone(), a2.clone()],
            Store(a1) => vec![a1.clone()],
            Sha3(a1) => vec![a1.clone()],
            Sha256(a1) => vec![a1.clone()],
            Blake2B(a1) => vec![a1.clone()],
            Lt(a1, a2) => vec![a1.clone(), a2.clone()],
            Gt(a1, a2) => vec![a1.clone(), a2.clone()],
            Eq(a1, a2) => vec![a1.clone(), a2.clone()],
            Elt(a1, a2) => vec![a1.clone(), a2.clone()],
            Egt(a1, a2) => vec![a1.clone(), a2.clone()],
            Neq(a1, a2) => vec![a1.clone(), a2.clone()],
            And(a1, a2) => vec![a1.clone(), a2.clone()],
            Or(a1, a2) => vec![a1.clone(), a2.clone()],
            Not(a1) => vec![a1.clone()],
            Tuple(a1) => vec![a1.clone()],
            Element(a1, a2) => vec![a1.clone(), a2.clone()],
            Setelement(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            MapEmpty => vec![],
            MapLookup(a1, a2) => vec![a1.clone(), a2.clone()],
            MapLookupd(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            MapUpdate(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            MapDelete(a1, a2) => vec![a1.clone(), a2.clone()],
            MapMember(a1, a2) => vec![a1.clone(), a2.clone()],
            MapFromList(a1) => vec![a1.clone()],
            MapSize(a1) => vec![a1.clone()],
            MapToList(a1) => vec![a1.clone()],
            IsNil(a1) => vec![a1.clone()],
            Cons(a1, a2) => vec![a1.clone(), a2.clone()],
            Hd(a1) => vec![a1.clone()],
            Tl(a1) => vec![a1.clone()],
            Length(a1) => vec![a1.clone()],
            Nil => vec![],
            Append(a1, a2) => vec![a1.clone(), a2.clone()],
            StrJoin(a1, a2) => vec![a1.clone(), a2.clone()],
            IntToStr(a1) => vec![a1.clone()],
            AddrToStr(a1) => vec![a1.clone()],
            StrReverse(a1) => vec![a1.clone()],
            StrLength(a1) => vec![a1.clone()],
            BytesToInt(a1) => vec![a1.clone()],
            BytesToStr(a1) => vec![a1.clone()],
            BytesConcat(a1, a2) => vec![a1.clone(), a2.clone()],
            BytesSplit(a1, a2) => vec![a1.clone(), a2.clone()],
            IntToAddr(a1) => vec![a1.clone()],
            Variant(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            VariantTest(a1, a2) => vec![a1.clone(), a2.clone()],
            VariantElement(a1, a2) => vec![a1.clone(), a2.clone()],
            BitsNonea => vec![],
            BitsNone => vec![],
            BitsAlla => vec![],
            BitsAll => vec![],
            BitsAllN(a1) => vec![a1.clone()],
            BitsSet(a1, a2) => vec![a1.clone(), a2.clone()],
            BitsClear(a1, a2) => vec![a1.clone(), a2.clone()],
            BitsTest(a1, a2) => vec![a1.clone(), a2.clone()],
            BitsSum(a1) => vec![a1.clone()],
            BitsOr(a1, a2) => vec![a1.clone(), a2.clone()],
            BitsAnd(a1, a2) => vec![a1.clone(), a2.clone()],
            BitsDiff(a1, a2) => vec![a1.clone(), a2.clone()],
            Balance => vec![],
            Origin => vec![],
            Caller => vec![],
            Blockhash(a1) => vec![a1.clone()],
            Beneficiary => vec![],
            Timestamp => vec![],
            Generation => vec![],
            Microblock => vec![],
            Difficulty => vec![],
            Gaslimit => vec![],
            Gas => vec![],
            Address => vec![],
            Gasprice => vec![],
            Log0(a1) => vec![a1.clone()],
            Log1(a1, a2) => vec![a1.clone(), a2.clone()],
            Log2(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            Log3(a1, a2, a3, a4) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()],
            Log4(a1, a2, a3, a4, a5) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone()],
            Spend(a1, a2) => vec![a1.clone(), a2.clone()],
            OracleRegister(a1, a2, a3, a4, a5, a6) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone()],
            OracleQuery(a1, a2, a3, a4, a5, a6, a7) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone(), a7.clone()],
            OracleRespond(a1, a2, a3, a4, a5, a6) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone()],
            OracleExtend(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            OracleGetAnswer(a1, a2, a3, a4) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()],
            OracleGetQuestion(a1, a2, a3, a4) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()],
            OracleQueryFee(a1) => vec![a1.clone()],
            AensResolve(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            AensPreclaim(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            AensClaim(a1, a2, a3, a4, a5) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone()],
            AensUpdate(a1, a2, a3, a4, a5, a6) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone()],
            AensTransfer(a1, a2, a3, a4) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()],
            AensRevoke(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            BalanceOther(a1) => vec![a1.clone()],
            VerifySig(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            VerifySigSecp256K1(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            ContractToAddress(a1) => vec![a1.clone()],
            AuthTxHash => vec![],
            OracleCheck(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            OracleCheckQuery(a1, a2, a3, a4) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()],
            IsOracle(a1) => vec![a1.clone()],
            IsContract(a1) => vec![a1.clone()],
            IsPayable(a1) => vec![a1.clone()],
            Creator => vec![],
            EcverifySecp256K1(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            EcrecoverSecp256K1(a1, a2) => vec![a1.clone(), a2.clone()],
            AddressToContract(a1) => vec![a1.clone()],
            Bls12_381G1Neg(a1) => vec![a1.clone()],
            Bls12_381G1Norm(a1) => vec![a1.clone()],
            Bls12_381G1Valid(a1) => vec![a1.clone()],
            Bls12_381G1IsZero(a1) => vec![a1.clone()],
            Bls12_381G1Add(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381G1Mul(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381G2Neg(a1) => vec![a1.clone()],
            Bls12_381G2Norm(a1) => vec![a1.clone()],
            Bls12_381G2Valid(a1) => vec![a1.clone()],
            Bls12_381G2IsZero(a1) => vec![a1.clone()],
            Bls12_381G2Add(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381G2Mul(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381GtInv(a1) => vec![a1.clone()],
            Bls12_381GtAdd(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381GtMul(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381GtPow(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381GtIsOne(a1) => vec![a1.clone()],
            Bls12_381Pairing(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381MillerLoop(a1, a2) => vec![a1.clone(), a2.clone()],
            Bls12_381FinalExp(a1) => vec![a1.clone()],
            Bls12_381IntToFr(a1) => vec![a1.clone()],
            Bls12_381IntToFp(a1) => vec![a1.clone()],
            Bls12_381FrToInt(a1) => vec![a1.clone()],
            Bls12_381FpToInt(a1) => vec![a1.clone()],
            AensLookup(a1) => vec![a1.clone()],
            OracleExpiry(a1) => vec![a1.clone()],
            AuthTx => vec![],
            StrToList(a1) => vec![a1.clone()],
            StrFromList(a1) => vec![a1.clone()],
            StrToUpper(a1) => vec![a1.clone()],
            StrToLower(a1) => vec![a1.clone()],
            CharToInt(a1) => vec![a1.clone()],
            CharFromInt(a1) => vec![a1.clone()],
            CallPgr(a1, a2, a3, a4, a5, a6, a7) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone(), a6.clone(), a7.clone()],
            Create(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            Clone(a1, a2, a3, a4) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone()],
            CloneG(a1, a2, a3, a4, a5) => vec![a1.clone(), a2.clone(), a3.clone(), a4.clone(), a5.clone()],
            BytecodeHash(a1) => vec![a1.clone()],
            Fee => vec![],
            AddressToBytes(a1) => vec![a1.clone()],
            Poseidon(a1, a2) => vec![a1.clone(), a2.clone()],
            Mulmod(a1, a2, a3) => vec![a1.clone(), a2.clone(), a3.clone()],
            Band(a1, a2) => vec![a1.clone(), a2.clone()],
            Bor(a1, a2) => vec![a1.clone(), a2.clone()],
            Bxor(a1, a2) => vec![a1.clone(), a2.clone()],
            Bnot(a1) => vec![a1.clone()],
            Bsl(a1, a2) => vec![a1.clone(), a2.clone()],
            Bsr(a1, a2) => vec![a1.clone(), a2.clone()],
            BytesSplitAny(a1, a2) => vec![a1.clone(), a2.clone()],
            BytesSize(a1) => vec![a1.clone()],
            BytesToFixedSize(a1, a2) => vec![a1.clone(), a2.clone()],
            IntToBytes(a1, a2) => vec![a1.clone(), a2.clone()],
            StrToBytes(a1) => vec![a1.clone()],
            DbgLoc(a1, a2) => vec![a1.clone(), a2.clone()],
            DbgDef(a1, a2) => vec![a1.clone(), a2.clone()],
            DbgUndef(a1, a2) => vec![a1.clone(), a2.clone()],
            DbgContract(a1) => vec![a1.clone()],
            Deactivate => vec![],
            Abort(a1) => vec![a1.clone()],
            Exit(a1) => vec![a1.clone()],
            Nop => vec![],
        }
    }

    pub fn addressing_mode(&self) -> AddressingMode {
        let args = self.args();
        let padded_args = match args.len() {
            0 => args,
            1..=4 => [[0].repeat(4 - args.len()).iter().map(|_| Arg::Stack(0)).collect(), args].concat(),
            5..=8 => [[0].repeat(8 - args.len()).iter().map(|_| Arg::Stack(0)).collect(), args].concat(),
            _ => panic!("Args length should be less than or equal to 8"),
        };
        if padded_args.len() == 4 {
            let mut m1: u8 = 0;
            for i in 0..4 {
                m1 <<= 2;
                m1 |= modifier_bits(&padded_args[i]);
            }
            AddressingMode::Short(m1)
        } else if padded_args.len() == 8 {
            let mut m1: u8 = 0;
            for i in 0..4 {
                m1 <<= 2;
                m1 |= modifier_bits(&padded_args[i]);
            }
            let mut m2: u8 = 0;
            for i in 4..8 {
                m2 <<= 2;
                m2 |= modifier_bits(&padded_args[i]);
            }
            AddressingMode::Long { low: m1, high: m2 }
        } else {
            panic!("Args were not padded correctly")
        }
    }
}
fn modifier_bits(arg: &crate::code::Arg) -> u8 {
    match arg {
        Arg::Stack(_) => 0b00,
        Arg::Arg(_) => 0b01,
        Arg::Var(_) => 0b10,
        Arg::Immediate(_) => 0b11,
    }
}
